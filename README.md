# Fluxtion service starter
A server for managing the deterministic execution of start and stop tasks for a set of interdependent services. Implemented
with [Fluxtion](https://github.com/v12technology/fluxtion) to manage the underlying directed acyclic graph of services.

### Overview
In many systems services execute independently but need to co-ordinate their lifecycle with each other. A service
may require all downstream services to be started before starting and becoming available to accept upstream requests.

Similarly, if a downstream service becomes unavailable all upstream services will need to be notified and take appropriate 
actions. 

As systems grow a complex graph of interdependent services quickly arises, the difficulty in correctly managing 
lifecycle overwhelms a handwritten manual solution. Service starter provides an automated utility for managing the lifecycle of independent services, executing
start and stop tasks associated with a particular service at the correct time.

### Main components
- **[ServiceManagerServer](https://github.com/gregv12/example-service-starter/blob/e9a6d092f492cd89060abc717c70f6539cf8f856/src/main/java/com/fluxtion/example/servicestater/ServiceManagerServer.java#L18)** manages the execution of lifecycle tasks associated with a service. The server places all 
 clients requests on a queue and executes them on its own thread. 
- **[Service](https://github.com/gregv12/example-service-starter/blob/e9a6d092f492cd89060abc717c70f6539cf8f856/src/main/java/com/fluxtion/example/servicestater/Service.java#L20)** - To manage a user service a proxy Service is instantiated and registered with the ServiceManagerServer. 
 An external service has a one to one mapping with a Service. Data held by the Service:
  - name - a unique service name that can be identified globally
  - dependents - Upstream services that require this service to be started for validity
  - start task - an optional task that is executed when the service enters the STARTING lifecycle phase
  - stop task - an optional task that is executed when the service enters the STOPPING lifecycle phase
- **Consumer<List<TaskWrapper>>** Consumes start/stop tasks generated by the ServiceManagerServer. A default implementation
 is provided, ServiceTaskExecutor, that executes tasks on its own executor thread.

#### Threading
ServiceManagerServer is threadsafe, all methods return immediately and a request is placed onto a queue for execution.
A single thread pulls the request from the queue and then reads/writes the underlying model.

A task list may be produced by the ServiceManagerServer and pushed to a registered consumer. A ServiceTaskExecutor 
instance is registered with the ServiceManagerServer by default. The ServiceTaskExecutor executes all tasks on its own 
thread.

  - serviceManagerThread-(n) processes client requests to the ServiceManager
  - taskExecutor-(n) executes tasks generated by the ServiceManager

### Programming overview
There are two phases for using the service starter. Phase 1 create and build a model. Phase 2 use the model in a running 
environment

#### Building a model
For each service to be managed create a Service, supply a name, optional start/stop tasks, list of services that depend
upon this service. Example service creation:

```java
Service handlerA = new Service("handlerA");
Service handlerB = new Service("handlerB");
//handlerA and handlerB require aggAB to be started before starting
//when starting aggAB execute the method ref CliTestClient::notifyStartedAggAB       
Service aggAB = new Service("aggAB", CliTestClient::notifyStartedAggAB, null, handlerA, handlerB);
```

The list of services is passed to an instance of [FluxtionServiceManager](https://github.com/gregv12/example-service-starter/blob/master/src/main/java/com/fluxtion/example/servicestater/graph/FluxtionServiceManager.java)
within the ServiceManagerServer using static builder methods. A ServiceManagerServer wraps the model for thread safe access, 
clients can only invoke methods on ServiceManagerServer shielding the FluxtionServiceManager.
```java
ServiceManagerServer serviceManagerServer = ServiceManagerServer.compiledServer(aggAB, handlerA, handlerB);
```

#### Executing a model
Once the server has been successfully built client code interacts in with the server:
  - Starting/stopping individual services by name 
  - Starting/stopping all services
  - When a service changes state, notify the server with the appropriate method and service name

### Auditing
To simplify debugging the behaviour an audit log is written recording all the relevant information, audit sample:
```
15:33:10.077 [serviceManagerThread-2] INFO  fluxtion.eventLog - eventLogRecord: 
    eventTime: -1
    logTime: 1639927990077
    groupingId: null
    event: NotifyServiceStarted
    eventToString: {GraphEvent.NotifyServiceStarted(super=name='persister')}
    eventFilter: persister
    nodeLogs: 
        - persister_stop: { method: notifyServiceStarted, initialStatus: STARTING, setStatus: STARTED}
        - aggAB_stop: { method: recalculateStatusForStop}
        - calcC_stop: { method: recalculateStatusForStop}
        - serviceStatusCache: { method: publishStatus}
        - commandPublisher: { method: publishCommands}
    endTime: 1639927990077
```

### Example Cli test client
To help understand the behaviour of the service controller a cli example has been created. The example builds a predetermined
service model and exposes that model as cli application for a user to experiment with, steps:

-  Navigate to [CliTestClient](https://github.com/gregv12/example-service-starter/blob/master/src/main/java/com/fluxtion/example/servicestater/helpers/CliTestClient.java)
-  Execute the main method in CliTestClient. A model will be built at startup and exposed through a cli, that executes methods
the ServiceManagerServer.

Extract from a sample session, a start task is attached to the persister service that will callback into the server and
indicate the persister service has started:
```

?

FluxtionService interactive tester commands:
===============================================
help or ?                 - print this message
build or b                - drops the graph and builds a new graph from scratch
status or ss              - prints the current status of the graph to console
startAll or sa            - start all services
stopAll or ha             - stop all services
start or s [service name] - start a single services by name
stop or h [service name]  - stop a single service by name
ns [service name]         - notify of started status for a single service by name
nh [service name]         - notify of stopped status for a single service by name
auditOn or aon            - turn audit recording on
auditOff or aoff          - turn audit recording on
exit or e                 - exit the application

>ss
>16:18:50.729 [serviceManagerThread-3] INFO  c.f.e.s.h.PublishServiceStatusRecordToLog - Current status:
(service='aggAB', status=STATUS_UNKNOWN)
(service='handlerC', status=STATUS_UNKNOWN)
(service='handlerB', status=STATUS_UNKNOWN)
(service='handlerA', status=STATUS_UNKNOWN)
(service='persister', status=STATUS_UNKNOWN)
(service='calcC', status=STATUS_UNKNOWN)
16:18:50.729 [serviceManagerThread-3] INFO  fluxtion.eventLog - eventLogRecord: 
    eventTime: 1639930730729
    logTime: 1639930730729
    groupingId: null
    event: PublishStatus
    eventToString: {GraphEvent.PublishStatus()}
    nodeLogs: 
        - serviceStatusCache: { method: publishCurrentStatus}
        - commandPublisher: { method: publishCommands}
    endTime: 1639930730729
16:18:50.729 [serviceManagerThread-3] INFO  fluxtion.eventLog - 
---

s persister
>16:19:05.643 [serviceManagerThread-3] INFO  c.f.e.s.graph.FluxtionServiceManager - start single service:persister
16:19:05.643 [serviceManagerThread-3] INFO  c.f.e.s.h.PublishServiceStatusRecordToLog - Current status:
(service='aggAB', status=STATUS_UNKNOWN)
(service='handlerC', status=STATUS_UNKNOWN)
(service='handlerB', status=STATUS_UNKNOWN)
(service='handlerA', status=STATUS_UNKNOWN)
(service='persister', status=WAITING_FOR_PARENTS_TO_START)
(service='calcC', status=STATUS_UNKNOWN)
16:19:05.643 [serviceManagerThread-3] INFO  fluxtion.eventLog - eventLogRecord: 
    eventTime: -1
    logTime: 1639930745643
    groupingId: null
    event: RequestServiceStart
    eventToString: {GraphEvent.RequestServiceStart(super=name='persister')}
    eventFilter: persister
    nodeLogs: 
        - persister_start: { method: startThisService, initialStatus: STATUS_UNKNOWN, setStatus: WAITING_FOR_PARENTS_TO_START, markStarting: true}
        - serviceStatusCache: { method: publishStatus}
        - commandPublisher: { method: publishCommands}
    endTime: 1639930745643
16:19:05.643 [serviceManagerThread-3] INFO  fluxtion.eventLog - 
---

16:19:05.643 [serviceManagerThread-3] INFO  fluxtion.eventLog - eventLogRecord: 
    eventTime: 1639930745643
    logTime: 1639930745643
    groupingId: null
    event: PublishStartTask
    eventToString: {GraphEvent.PublishStartTask()}
    nodeLogs: 
        - persister_stop: { method: publishStartTasks, initialStatus: WAITING_FOR_PARENTS_TO_START, setStatus: STARTING}
        - aggAB_stop: { method: publishStartTasks}
        - calcC_stop: { method: publishStartTasks}
        - handlerA_stop: { method: publishStartTasks}
        - handlerB_stop: { method: publishStartTasks}
        - handlerC_stop: { method: publishStartTasks}
        - commandPublisher: { method: publishCommands}
    endTime: 1639930745643
16:19:05.643 [serviceManagerThread-3] INFO  fluxtion.eventLog - 
---

16:19:05.643 [serviceManagerThread-3] INFO  c.f.e.s.h.PublishServiceStatusRecordToLog - Current status:
(service='aggAB', status=STATUS_UNKNOWN)
(service='handlerC', status=STATUS_UNKNOWN)
(service='handlerB', status=STATUS_UNKNOWN)
(service='handlerA', status=STATUS_UNKNOWN)
(service='persister', status=STARTING)
(service='calcC', status=STATUS_UNKNOWN)
16:19:05.643 [serviceManagerThread-3] INFO  fluxtion.eventLog - eventLogRecord: 
    eventTime: 1639930745643
    logTime: 1639930745643
    groupingId: null
    event: PublishStatus
    eventToString: {GraphEvent.PublishStatus()}
    nodeLogs: 
        - serviceStatusCache: { method: publishCurrentStatus}
        - commandPublisher: { method: publishCommands}
    endTime: 1639930745643
16:19:05.643 [serviceManagerThread-3] INFO  fluxtion.eventLog - 
---

16:19:05.643 [taskExecutor-2] INFO  c.f.e.s.helpers.ServiceTaskExecutor - executing TaskWrapper{serviceName='persister'startTask='true'}
16:19:05.643 [taskExecutor-2] INFO  c.f.e.s.helpers.CliTestClient - persister::startTask notify persister STARTED
16:19:05.659 [serviceManagerThread-3] INFO  c.f.e.s.graph.FluxtionServiceManager - GraphEvent.NotifyServiceStarted(super=name='persister')
16:19:05.659 [serviceManagerThread-3] INFO  c.f.e.s.h.PublishServiceStatusRecordToLog - Current status:
(service='aggAB', status=STATUS_UNKNOWN)
(service='handlerC', status=STATUS_UNKNOWN)
(service='handlerB', status=STATUS_UNKNOWN)
(service='handlerA', status=STATUS_UNKNOWN)
(service='persister', status=STARTED)
(service='calcC', status=STATUS_UNKNOWN)
16:19:05.659 [serviceManagerThread-3] INFO  fluxtion.eventLog - eventLogRecord: 
    eventTime: -1
    logTime: 1639930745659
    groupingId: null
    event: NotifyServiceStarted
    eventToString: {GraphEvent.NotifyServiceStarted(super=name='persister')}
    eventFilter: persister
    nodeLogs: 
        - persister_stop: { method: notifyServiceStarted, initialStatus: STARTING, setStatus: STARTED}
        - aggAB_stop: { method: recalculateStatusForStop}
        - calcC_stop: { method: recalculateStatusForStop}
        - serviceStatusCache: { method: publishStatus}
        - commandPublisher: { method: publishCommands}
    endTime: 1639930745659
16:19:05.659 [serviceManagerThread-3] INFO  fluxtion.eventLog - 
---
```

### Service lifecycle
The service starter manages a set of services with the following behaviour
1. A service can be started if all its dependencies are in a STARTED state
2. A service can be started if it has no dependencies
3. A call to FluxtionSystemManager.start() will start any services that have no dependencies
4. Any service the FluxtionSystemManager starts will move to the STARTING state, and a [start command](https://github.com/gregv12/example-service-starter/blob/d15d4856af4f0315d08474de5fda74f849886757/src/main/java/com/fluxtion/example/servicestater/ServiceEvent.java#L57) will be published
5. Any dependencies of a STARTING service will move to WAITING_FOR_PARENTS_TO_START state
6. A service moves to STARTED state when a StatusUpdate with STARTED state is invoked by calling FluxtionSystemManager.processStatusUpdate() 
7. When all dependencies of a WAITING_FOR_PARENTS_TO_START service have STARTED state this service will be started, see (4) above
9. Continues down the dependency tree until all services are started

Stopping has the same behaviour for the reverse dependency order.

### States
    STATUS_UNKNOWN,
    WAITING_FOR_PARENTS_TO_START,
    STARTING,
    STARTED,
    WAITING_FOR_PARENTS_TO_STOP,
    STOPPING,
    STOPPED,
